# Source Code Context

## Directory Structure

```
src/
├── components/
│   ├── Cropper.tsx        # Main wrapper component
│   └── Cropper.test.tsx   # Component tests (25 tests)
├── hooks/
│   ├── useCropper.ts      # Composable hook
│   └── useCropper.test.ts # Hook tests (24 tests)
├── types/
│   ├── index.ts           # Type definitions
│   └── jsx.d.ts           # JSX namespace for custom elements
└── index.ts               # Main export file
```

## Module Exports

### Main Entry (`index.ts`)
```typescript
// Components
export { Cropper } from './components/Cropper';
export type { CropperProps, CropperRef } from './components/Cropper';

// Hooks
export { useCropper } from './hooks/useCropper';
export type { UseCropperOptions, UseCropperReturn } from './hooks/useCropper';

// Types
export type {
  CropperCanvasElement,
  CropperSelectionElement,
  CropperBounds,
  CropperEventHandler,
} from './types';
```

## Component API

### Cropper Component (`components/Cropper.tsx`)

**Purpose:** High-level declarative React wrapper for CropperJS 2.x

**Key Features:**
- Wraps `<cropper-canvas>` and `<cropper-selection>` web components
- Forward ref with imperative handle
- Event callback props
- Full TypeScript support

**Props Interface:**
```typescript
interface CropperProps {
  // Required
  src: string;

  // Canvas properties
  background?: boolean;
  rotatable?: boolean;
  scalable?: boolean;
  skewable?: boolean;
  translatable?: boolean;

  // Selection properties
  aspectRatio?: number;
  initialAspectRatio?: number;
  initialCoverage?: number;
  movable?: boolean;
  resizable?: boolean;
  zoomable?: boolean;
  multiple?: boolean;
  outlined?: boolean;

  // Styling
  alt?: string;
  className?: string;
  style?: React.CSSProperties;

  // Event callbacks
  onReady?: (canvas: CropperCanvasElement) => void;
  onChange?: CropperEventHandler;
  onCropStart?: CropperEventHandler;
  onCropMove?: CropperEventHandler;
  onCropEnd?: CropperEventHandler;
}
```

**Ref API:**
```typescript
interface CropperRef {
  getCanvas: () => CropperCanvasElement | null;
  getSelection: () => CropperSelectionElement | null;
  getBounds: () => CropperBounds | null;
  setBounds: (bounds: Partial<CropperBounds>) => void;
  reset: () => void;
  clear: () => void;
}
```

**Implementation Pattern:**
1. Refs for DOM elements (canvas, selection)
2. Refs for callbacks (prevents stale closures)
3. Effect to sync callback refs
4. useImperativeHandle for ref API
5. Effect for event listeners (runs once, deps: [])
6. JSX with custom elements

**Critical Pattern - Callback Refs:**
```typescript
// Store callbacks in refs to prevent stale closures
const onReadyRef = useRef(onReady);
const onChangeRef = useRef(onChange);
// ... more callback refs

// Update refs when props change
useEffect(() => {
  onReadyRef.current = onReady;
  onChangeRef.current = onChange;
  // ... update other refs
});

// Use refs in event setup (empty dependency array)
useEffect(() => {
  // Event listeners use onReadyRef.current, not onReady
  if (onReadyRef.current) {
    onReadyRef.current(canvas);
  }
  // ...
}, []); // Empty deps - listeners attached once
```

## Hook API

### useCropper Hook (`hooks/useCropper.ts`)

**Purpose:** Composable hook for advanced CropperJS usage

**Options Interface:**
```typescript
interface UseCropperOptions {
  onReady?: (canvas: CropperCanvasElement) => void;
  onChange?: CropperEventHandler;
  onCropStart?: CropperEventHandler;
  onCropMove?: CropperEventHandler;
  onCropEnd?: CropperEventHandler;
  autoInitialize?: boolean; // default: true
}
```

**Return Interface:**
```typescript
interface UseCropperReturn {
  // Refs to attach to elements
  canvasRef: React.RefObject<CropperCanvasElement>;
  selectionRef: React.RefObject<CropperSelectionElement>;

  // State
  bounds: CropperBounds | null;
  isReady: boolean;

  // Methods
  getBounds: () => CropperBounds | null;
  setBounds: (bounds: Partial<CropperBounds>) => void;
  reset: () => void;
  clear: () => void;
  getCanvas: () => CropperCanvasElement | null;
  getSelection: () => CropperSelectionElement | null;
}
```

**Implementation Pattern:**
1. Refs for DOM elements
2. State for bounds and isReady
3. Refs for callbacks (prevents stale closures)
4. Effect to sync callback refs
5. Effect to detect when refs are ready
6. Effect for initialization and event setup
7. Memoized methods (useCallback)

**State Management:**
```typescript
// Internal state
const [bounds, setBoundsState] = useState<CropperBounds | null>(null);
const [isReady, setIsReady] = useState(false);
const [refsReady, setRefsReady] = useState(false);

// Effect to detect refs availability
useEffect(() => {
  if (canvasRef.current && selectionRef.current && !refsReady) {
    setRefsReady(true);
  }
}, [autoInitialize, refsReady]);

// Effect runs when refs become ready
useEffect(() => {
  if (!autoInitialize || !refsReady) return;
  // Initialize and attach event listeners
}, [autoInitialize, refsReady, getBounds]);
```

## Type Definitions

### Core Types (`types/index.ts`)

**CropperJS Element Interfaces:**
```typescript
interface CropperCanvasElement extends HTMLElement {
  // CropperJS canvas element
  // Methods added by CropperJS
}

interface CropperSelectionElement extends HTMLElement {
  getBounds(): CropperBounds;
  setBounds(bounds: Partial<CropperBounds>): void;
  reset(): void;
  clear(): void;
  // More methods...
}
```

**Data Types:**
```typescript
interface CropperBounds {
  x: number;
  y: number;
  width: number;
  height: number;
}

type CropperEventHandler = (
  event: CustomEvent<{ bounds: CropperBounds }>
) => void;
```

### JSX Types (`types/jsx.d.ts`)

**Purpose:** Enable TypeScript to recognize custom elements

```typescript
declare global {
  namespace JSX {
    interface IntrinsicElements {
      'cropper-canvas': React.DetailedHTMLProps<
        React.HTMLAttributes<HTMLElement> & {
          src?: string;
          background?: boolean;
          // ... more props
        },
        HTMLElement
      >;
      'cropper-selection': React.DetailedHTMLProps<
        React.HTMLAttributes<HTMLElement> & {
          'aspect-ratio'?: number;
          movable?: boolean;
          // ... more props
        },
        HTMLElement
      >;
    }
  }
}
```

## Testing Patterns

### Component Testing (`*.test.tsx`)

**Test Structure:**
1. Mock setup (beforeEach)
2. Rendering tests
3. Props tests
4. Event handler tests
5. Ref method tests
6. Edge case tests

**Mock Pattern:**
```typescript
beforeEach(() => {
  // Mock web component elements
  HTMLElement.prototype.getBounds = vi.fn(() => ({
    x: 10, y: 20, width: 100, height: 80
  }));
  HTMLElement.prototype.setBounds = vi.fn();
  // ... more mocks
});
```

### Hook Testing (`useCropper.test.ts`)

**Custom Test Helper:**
```typescript
function renderHookWithRefs(options = {}) {
  let hookReturn = null;

  function TestComponent() {
    const hook = useCropper(options);
    hookReturn = hook;

    // Attach mock refs on first render
    if (hook.canvasRef.current === null) {
      Object.defineProperty(hook.canvasRef, 'current', {
        value: mockCanvas,
        writable: true,
        configurable: true,
      });
    }
    // ... same for selectionRef

    return null;
  }

  const renderResult = render(createElement(TestComponent));
  return {
    result: { get current() { return hookReturn!; } },
    ...renderResult,
  };
}
```

**Why This Pattern:**
- Standard `renderHook` doesn't trigger effects when refs are set
- This helper simulates real component lifecycle
- Refs are set during render, triggering effects properly

## Common Patterns

### Event Listener Management

```typescript
// Pattern: Collect handlers for cleanup
const handlers: Array<{
  element: HTMLElement;
  event: string;
  handler: EventListener;
}> = [];

const addEventListener = (
  element: HTMLElement,
  event: string,
  handler: EventListener
): void => {
  element.addEventListener(event, handler);
  handlers.push({ element, event, handler });
};

// Attach listeners
addEventListener(selection, 'change', handleChange);
addEventListener(selection, 'cropstart', onCropStartRef.current);

// Cleanup
return () => {
  handlers.forEach(({ element, event, handler }) => {
    element.removeEventListener(event, handler);
  });
};
```

### Error Handling

```typescript
// Pattern: Try-catch with null return
getBounds(): CropperBounds | null {
  const selection = selectionRef.current;
  if (!selection) return null;

  try {
    return selection.getBounds();
  } catch {
    return null; // Silent failure
  }
}
```

## Code Style Guidelines

### TypeScript
- Use interfaces for object shapes
- Use type for unions/intersections
- Explicit return types on functions
- No `any` types
- Optional chaining (`?.`) for safety

### React
- Functional components only
- Hooks for state and effects
- `useCallback` for functions passed as props
- `useMemo` for expensive computations (when needed)
- Forward ref when exposing imperative API

### Naming
- PascalCase for components and types
- camelCase for functions and variables
- UPPER_CASE for constants
- Prefix interfaces with `I` (not used - use plain names)
- Prefix types with `T` (not used - use plain names)

### Comments
- JSDoc for public APIs
- Inline comments for complex logic
- No obvious comments
- Explain "why" not "what"

## Performance Considerations

### Current Optimizations
- ✅ `useCallback` for stable function references
- ✅ `useImperativeHandle` minimizes re-renders
- ✅ Event listeners attached once (not on every render)
- ✅ Refs for callbacks prevent re-runs
- ✅ Empty dependency arrays where appropriate

### Potential Issues
- ⚠️ `bounds` state updates on every change (could be optimized)
- ⚠️ No debouncing for frequent events
- ⚠️ No memoization for computed values

## Debugging Tips

### Common Issues

1. **Event handlers not firing**
   - Check that refs are properly set
   - Verify `refsReady` state in hook
   - Check browser console for errors

2. **Stale closure bugs**
   - Ensure callbacks are stored in refs
   - Verify refs are updated in effect
   - Check dependency arrays

3. **TypeScript errors with JSX**
   - Verify `jsx.d.ts` is included
   - Check tsconfig includes src directory
   - Restart TypeScript server

### Testing Failures

1. **Refs not triggering effects**
   - Use `renderHookWithRefs` helper
   - Check that refs are set synchronously
   - Verify `waitFor` is used for async updates

2. **Event not dispatched**
   - Ensure element is in document
   - Use `CustomEvent` for proper typing
   - Check event name matches listener

## Maintenance Checklist

### Before Committing
- [ ] All tests pass (`npm test`)
- [ ] TypeScript checks pass (`npm run typecheck`)
- [ ] Linting passes (`npm run lint`)
- [ ] Code formatted (`npm run format`)
- [ ] Build succeeds (`npm run build`)

### Before Releasing
- [ ] Update version in package.json
- [ ] Update CHANGELOG.md
- [ ] Test in example app
- [ ] Verify types are exported
- [ ] Check bundle size
- [ ] Create git tag
- [ ] npm publish
